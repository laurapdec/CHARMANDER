import matplotlib.pyplot as plt
import math
import numpy as np
from tkinter import *
import pyglet
from tkinter import ttk
import imageio
import random
import cantera as ct
from mpl_toolkits.mplot3d import Axes3D
from os import remove
from numpy.random import random
from random import randint
from math import exp


###############################################################################
##                         CLASSE INTERFACE GRÁFICA                          ##
###############################################################################


class App:
    def __init__(self,master):

        self.master=master

        self.elements=[]

        CTIlabel = ttk.Labelframe(master, text='Select the .CTI file')
        self.CTIvar = StringVar()
        CTIcombo = ttk.Combobox(CTIlabel,state="readonly", textvariable=self.CTIvar ,values=["GRI Mech 3.0", "SP21RE"])
        
        CTIcombo.grid(pady=5, padx=10)
        CTIlabel.grid(row=0, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)       


        Button(CTIlabel,text="OK",command=self.checkCTI).grid(row=0, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 

        ## Mixture Model

        MODELlabel = ttk.Labelframe(master, text='Select the mixture model')
        self.MODELvar = StringVar()
        MODELcombo = ttk.Combobox(MODELlabel,state="readonly", textvariable=self.MODELvar ,values=["Curl","Curl Modificado","IEM/LMSE", "EIEM","Langevin","Langevin Estendido"])
        
        MODELcombo.grid(pady=5, padx=10)
        MODELlabel.grid(row=0,column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)       

        ## Simulation time parameters

        TimeLabel = ttk.Labelframe(master, text='Velocities')
        TimeLabel.grid(row=0,column=2, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)  
        
        
        Label(master,text="t_f [s] :").grid(in_=TimeLabel,row=3, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        self.TFstring=StringVar()
        self.TFstring.set(0.003)
        self.entryTF=Entry(master,textvariable=self.TFstring)
        self.entryTF.grid(in_=TimeLabel,row=3, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        
        Label(master,text="dt [s] :").grid(in_=TimeLabel,row=4, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        self.DTstring=StringVar()
        self.DTstring.set(0.0001)
        self.entryDT=Entry(master,textvariable=self.DTstring)
        self.entryDT.grid(in_=TimeLabel,row=4, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 




        ## Boundary Conditions
        
        
        Boundlabel = ttk.Labelframe(master, text='Boundary Conditions')
        Boundlabel.grid(sticky=E+W,columnspan=2,padx=5, pady=5, ipadx=5, ipady=5)

        # Setting Composition


        BigFrame=Frame(Boundlabel)

        BigFrame.grid(column=2,row=0,sticky=W+N,rowspan=30)

        self.canvas = Canvas(BigFrame, width=200, height=500)
        self.CompositionLabel = ttk.Labelframe(self.canvas, text='Compositions')
        sbar = Scrollbar(BigFrame, orient="vertical", command=self.canvas.yview)
        
        self.canvas.config(yscrollcommand=sbar.set)

        self.canvas.pack(side="left")
        sbar.pack(side="left", fill="y")
        self.canvas.create_window((2,2), window=self.CompositionLabel, anchor="nw",  tags="self.CompositionLabel")        
        
        self.CompositionLabel.bind("<Configure>", self.onFrameConfigure)
        

        
                
        # Select Wall

        Label(master,text="Select the wall :").grid(in_=Boundlabel,row=0,column=0 ,sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        self.Boundvar = StringVar()
        Boundcombo = ttk.Combobox(Boundlabel,state="readonly", textvariable=self.Boundvar ,values=["LEFT", "RIGHT", "FRONT", "BACK", "UP", "DOWN"])
        Boundcombo.grid(row=0,column=1,pady=5, padx=10)

        
        
        # Create particles here?
        
        
        self.createPart = IntVar()
        self.checkIn=Checkbutton(Boundlabel, text="Generate particles in this Wall?",variable=self.createPart,command=self.checkenable)
        self.checkIn.grid(sticky=W,row=1,columnspan=2)


        # Setting Number of Particles
        
        Label(master,text="Number of particles generated by time step :").grid(in_=Boundlabel,row=2 ,sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        self.Nstring=StringVar()
        self.entryN=Entry(master,textvariable=self.Nstring,state='disabled')
        self.Nstring.set(0)
        self.entryN.grid(in_=Boundlabel,row=2, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        
        # Setting Temperature
        
        Label(master,text="T [K] :").grid(in_=Boundlabel,row=3 ,sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        self.Tstring=StringVar()
        self.entryT=Entry(master,textvariable=self.Tstring,state='disabled')
        self.entryT.grid(in_=Boundlabel,row=3, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)


        
        
        # Setting Velocities

        VelocityLabel = ttk.Labelframe(Boundlabel, text='Velocities')
        VelocityLabel.grid(sticky=E+W,row=4,padx=5, pady=5, ipadx=5, ipady=5,columnspan=2)
        
        
        Label(master,text="u [m/s] :").grid(in_=VelocityLabel,row=3, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        self.Ustring=StringVar()
        self.Ustring.set(0)
        self.entryU=Entry(master,textvariable=self.Ustring,state='disabled')
        self.entryU.grid(in_=VelocityLabel,row=3, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        
        Label(master,text="v [m/s] :").grid(in_=VelocityLabel,row=4, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        self.Vstring=StringVar()
        self.Vstring.set(0)
        self.entryV=Entry(master,textvariable=self.Vstring,state='disabled')
        self.entryV.grid(in_=VelocityLabel,row=4, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 

        Label(master,text="w [m/s] :").grid(in_=VelocityLabel,row=5, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        self.Wstring=StringVar()
        self.Wstring.set(0)
        self.entryW=Entry(master,textvariable=self.Wstring,state='disabled')
        self.entryW.grid(in_=VelocityLabel,row=5, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 




        # Wall Reflect or Pass
        
        self.WallReflect = IntVar()
        Checkbutton(Boundlabel, text="Reflects?", variable=self.WallReflect).grid(row=5, sticky=W,columnspan=2)

        # Save Wall
        
        self.save=Button(Boundlabel,text="Save Wall",command=self.saveWall)
        self.save.grid(row=6, columnspan=2, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        



        ## Plot Configure

        ## Run
        
        self.run=Button(master,text="Run",command=self.running)
        self.run.grid(row=0, column=3, sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
        
    def newWall(self):
        
        self.Nstring.set(0)
        self.Ustring.set(0)
        self.Vstring.set(0)
        self.Wstring.set(0)
        self.WallReflect.set(0)

    def saveWall(self):

        if self.createPart.get()==1:
            stringComposition_temp=[]

            for id,comp in enumerate(self.stringComposition):
                stringComposition_temp.append(comp.get())

            if self.Boundvar.get() == "LEFT":
                strin=1
            elif self.Boundvar.get() == "RIGHT":
                strin=2
            elif self.Boundvar.get() == "FRONT":
                strin=3
            elif self.Boundvar.get() == "BACK":
                strin=4
            elif self.Boundvar.get() == "UP":
                strin=5
            elif self.Boundvar.get() == "DOWN":
                strin=6
            self.Wall[strin-1]['Nstring']=self.Nstring.get()
            self.Wall[strin-1]['Tstring']=self.Tstring.get()
            self.Wall[strin-1]['Ustring']=self.Ustring.get()
            self.Wall[strin-1]['Vstring']=self.Vstring.get()
            self.Wall[strin-1]['Wstring']=self.Wstring.get()
            self.Wall[strin-1]['WallReflect']=self.WallReflect.get()
            self.Wall[strin-1]['stringComposition']=stringComposition_temp


        self.save.config(bg='green')
                    
    def checkCTI(self):


        for id, field in enumerate(self.elements):
            self.entryComposition[id].grid_forget()
            self.labelComposition[id].grid_forget()

            
        if (self.CTIvar.get()=="SP21RE"):
            self.CTIfile="CTI Files\\sp21re.cti"
        elif (self.CTIvar.get()=="GRI Mech 3.0"):
            self.CTIfile="CTI Files\\GRI30.cti"

        doc=open(self.CTIfile,'r')
        print(self.CTIfile, "was just imported")
        content=doc.read()
        index=content.find("species=")
        index=index+11
        elements=''
        while content[index] != '"':
            elements+=content[index]
            index+=1
        self.elements=elements.split()

        global elementos
        elementos=self.elements
        
        self.stringComposition=[0]*len(self.elements)
        self.labelComposition=[0]*len(self.elements)
        self.entryComposition=[0]*len(self.elements)

        
        for id, field in enumerate(self.elements):
            self.labelComposition[id]=Label(self.CompositionLabel,text=field)
            self.labelComposition[id].grid(row=id ,sticky='W', padx=5, pady=5, ipadx=5, ipady=5) 
            self.stringComposition[id]=StringVar()
            self.stringComposition[id].set(0)
            self.entryComposition[id]=Entry(self.CompositionLabel,textvariable=self.stringComposition[id],state='disabled')
            self.entryComposition[id].grid(row=id, column=1, sticky='W', padx=5, pady=5, ipadx=5, ipady=5)
        self.checkenable()

        self.Wall=[]
        for i in range(0,6):
            self.Wall.append({'Nstring':'0','Tstring':'0','Ustring':'0','Vstring':'0','Wstring':'0','stringComposition':[0]*len(self.elements),'WallReflect':0})
        self.save.config(bg='red')

    def onFrameConfigure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def checkenable(self):
        if (self.createPart.get()==0):
            self.entryT.configure(state='disabled')
            self.entryN.configure(state='disabled')
            self.entryU.configure(state='disabled')
            self.entryV.configure(state='disabled')
            self.entryW.configure(state='disabled')
            for id, field in enumerate(self.elements):
                self.entryComposition[id].configure(state='disabled')
                

        else:
            self.entryT.configure(state='normal')
            self.entryN.configure(state='normal')
            self.entryU.configure(state='normal')
            self.entryV.configure(state='normal')
            self.entryW.configure(state='normal')
            for id, field in enumerate(self.elements):
                self.entryComposition[id].configure(state='normal')

    def saveInput(self):

        print("The conditions set are available in the file setup.txt in the folder OUTPUT")
        setup=open("OUTPUT\\setup.txt",'w')

        for i in range(0,6):
            name="\n \n Wall " +str(i+1)+ " \n \n "
            setup.write(name)
            setup.write("\n N:"+self.Wall[i]['Nstring'])
            setup.write("\n T:"+self.Wall[i]['Tstring'])
            setup.write("\n U:"+self.Wall[i]['Ustring'])
            setup.write("\n V:"+self.Wall[i]['Vstring'])
            setup.write("\n W:"+self.Wall[i]['Wstring'])
            setup.write("\n Wall Reflect:"+str(self.Wall[i]['WallReflect']))
            setup.write("\n Composition: \n")
            for id, element in enumerate(self.elements):
                setup.write(element+":"+str(self.Wall[i]['stringComposition'][id]) + '\n')

        setup.close()

    def running(self):

        timer_id = None
        imagelist=["loading\\frame_00.gif","loading\\frame_01.gif","loading\\frame_02.gif","loading\\frame_03.gif","loading\\frame_04.gif","loading\\frame_05.gif","loading\\frame_06.gif","loading\\frame_07.gif","loading\\frame_08.gif","loading\\frame_09.gif"]    
        photo = PhotoImage(file=imagelist[0])
        width = photo.width()
        height = photo.height()
        self.canvasload = Canvas(self.master,width=width, height=height)
        self.canvasload.grid(row=1,column=3)

        self.giflist = []
        for imagefile in imagelist:
            photo = PhotoImage(file=imagefile)
            self.giflist.append(photo)
        self.start_loading()
        self.saveInput()

        Simulate(self.Wall,self.DTstring,self.TFstring)

        self.stop_loading()

    def start_loading(self,n=0):
        global timer_id
        self.canvasload.delete(ALL)
        gif = self.giflist[n % len(self.giflist)]
        self.canvasload.create_image(gif.width()//2, gif.height()//2, image=gif)
        timer_id = root.after(50, self.start_loading, n+1) # call this function every 100ms

    def stop_loading(self):
        if timer_id:
            root.after_cancel(timer_id)


###############################################################################
##                               CLASSE PARTÍCULA                            ##
###############################################################################


class part():
	def __init__(self,position,velocity,comp,T):
	    global elementos
	    [x,y,z]=position 
	    [u,v,w]=velocity
	    self.x=x
	    self.y=y
	    self.z=z

	    self.u=u
	    self.v=v
	    self.w=w

	    self.T=T
	    self.comp=comp


	    self.old_position=np.array([100,100,100])

	    self.gamma=0.01
	    self.gamma_old=0.01
	    self.gamma_t=0.0
	    self.gamma_t_old=0.0

	    self.P=101325       #[Pa]
	    self.rho=287/self.P*self.T      #[Kg/m³]

	    self.R_r=0

	    omega_te=C_omega*(self.gamma+self.gamma_t)/(delta**2)
	    self.omega={}
	    for id, element in enumerate(elementos):
	        self.omega[elementos[id]]=omega_te


	    self.gas=ct.Solution('CTI Files\\sp21re.cti')
	    self.gas.X=self.comp

	def getPosition(self):
		return np.array([self.x,self.y,self.z])

	def getOlderPosition(self):
		return self.old_position

	def getVelocity(self):
		return np.array([self.u,self.v,self.w])

	def setPosition(self,pos):
	    self.old_position=np.array([self.x,self.y,self.z])
	    self.x=pos[0]
	    self.y=pos[1]
	    self.z=pos[2]

	def setVelocity(self,vel):
	    self.u=vel[0]
	    self.v=vel[1]
	    self.w=vel[2]

	def updateGamma(self,new):
	    self.gamma_old=self.gamma
	    self.gamma=new

	def updateTemp(self):
	    self.T=(2000-560)*self.comp["H2O"]+560
	    self.rho=287/self.P*self.T      #[Kg/m³]


###############################################################################
##                              FUNÇÕES DO PROGRAMA                          ##
###############################################################################


def random_float(min,max):
  result=0
  while result >=max or result<=min:
    result=random()*(max-min)+min
  return result

def plot_3D(x,y,z,c):
    global frame_3D,filenames_3D
    fig=plt.figure()
    ax = fig.add_subplot(1,1,1, projection='3d')
    pnt1=ax.scatter(x,y,z,c=c,cmap=plt.cm.jet, edgecolor='black')
    cbar=plt.colorbar(pnt1)
    pnt1.set_clim(0.0,1.0)
    plt.xlim(0.0,1.0)
    plt.ylim(0.0,1.0)
    ax.set_zlim3d(0.0,1.0)
    cbar.set_label("% de $H_2O$")
    ax.set_xlabel('Eixo x')
    ax.set_ylabel('Eixo y')
    ax.set_zlabel('Eixo z')
    frame_3D[0]+=1
    frame_3D[1]=t
    name='OUTPUT/frames/t_'+str(frame_3D[0])+'.png'
    filenames_3D.append(name)
    plt.savefig(name)
    plt.close('all')

def plot_comp(x,p):
    global filenames_comp,frame_comp
    #plt.plot(x,h,'.b',LineWidth=0.1)
    plt.plot(x,p,'.g',LineWidth=0.1)
    #plt.plot(x,o,'.r',LineWidth=0.1)
    plt.axis([0,1,0,1])
    plt.xlabel('Eixo x')
    plt.ylabel('%')
    plt.legend(["$H_2$","$H_2O$","$O_2$"])
    frame_comp[0]+=1
    frame_comp[1]=t
    name='OUTPUT/frames/h_'+str(frame_comp[0])+'.png'
    filenames_comp.append(name)
    plt.savefig(name)
    plt.close('all')

def plot_PDF(data): 
    global frame_PDF,filenames_PDF,frame_CDF,filenames_CDF
    p=np.zeros(len(data))
    k=0
    for i in range(0,len(data)):  
        for r in np.linspace(0,1,len(p)):
            if data[i] >= r and data[i] <= n_div + r:
                p[k] += 1
            k +=1
        k=0

    
    x = np.linspace(0, 1 , len(p))
    pp= np.array(p)*100 / npart
  
    plt.plot(x, p, 'bo-')
    plt.axis([-0.1,1.1,0,len(p)])
    plt.grid()
    plt.ylabel('[$H_2O$]')
    frame_CDF[0]+=1
    frame_CDF[1]=t
    name='OUTPUT/frames/cdf_'+str(frame_CDF[0])+'.png'
    filenames_CDF.append(name)
    plt.savefig(name)
    plt.close('all')
  
    plt.plot(x, pp, 'r.-')
    plt.axis([-0.1,1.1,0,100])
    plt.ylabel('Probabilidade de $H_2O$ %')
    plt.xlabel('[$H_2O$]')
    plt.grid()
    #plt.legend(["$H_2$","$H_2O$","$O_2$"])
    frame_PDF[0]+=1
    frame_PDF[1]=t
    name='OUTPUT/frames/pdf_'+str(frame_PDF[0])+'.png'
    filenames_PDF.append(name)
    plt.savefig(name)
    plt.close('all')

def Simulate(Wall,DT,TF):

        global frame_3D,frame_CDF,frame_comp,frame_PDF,filenames_3D,filenames_comp,filenames_CDF,filenames_PDF,t,npart

        part_u=[]
        filenames_3D=[]
        filenames_comp=[]
        filenames_CDF=[]
        filenames_PDF=[]

        frame_3D=[0,0]
        frame_CDF=[0,0]
        frame_comp=[0,0]
        frame_PDF=[0,0]

        dt=float(DT.get())          #Passo de Tempo
        t_f=float(TF.get())         #Tempo final



        for i_wall in range (0,6):
            npart=int(Wall[i_wall]["Nstring"])
            if npart>0:
                for dist in np.linspace(0,1,num=npart):
                    u=float(Wall[i_wall]["Ustring"])
                    v=float(Wall[i_wall]["Vstring"])
                    w=float(Wall[i_wall]["Wstring"])
                    T=float(Wall[i_wall]["Tstring"])
                    rand=random()
                    if i_wall==0:
                        x=0
                        y=dist
                        z=rand
                    elif i_wall==1:
                        x=1
                        y=dist
                        z=rand
                    elif i_wall==2:
                        x=dist
                        y=0
                        z=dist
                    elif i_wall==3:
                        x=dist
                        y=1
                        z=rand
                    elif i_wall==4:
                        x=dist
                        y=rand
                        z=0
                    elif i_wall==5:
                        x=dist
                        y=rand
                        z=1
                    comp={}
                    for id, element in enumerate(elementos):
                        comp[element]=float(Wall[i_wall]['stringComposition'][id])

                    part_u.append(part([x,y,z],[u,v,w],comp,T))



        V_avg=np.zeros(3)

        ###############################################################################
        ##                          INÍCIO DO LOOP                                   ##
        ###############################################################################
          
          
        for t in np.linspace(0,t_f,int(t_f/dt)):

          #Resetando os vetores e valores necessários
            x=[]
            y=[]
            z=[]
            h=[]
            o=[]
            p=[]
            l=0
            V_avg=np.array([.0,.0,.0])
            c_avg={}
            for id, element in enumerate(elementos):
                c_avg[element]=0

          #Excluindo particulas fora do volume de controle e movendo as outras

            npart=len(part_u)
            for id, part_i in enumerate(part_u):
              V_avg+=part_i.getVelocity()
            V_avg=V_avg/npart
            for id,part_i in enumerate(part_u):
                if (part_i.x >1) or (part_i.x <0) or (part_i.y >1) or (part_i.y <0) or (part_i.z >1) or (part_i.z <0):
                    del(part_u[id - l])
                    l += 1
                else:
                    dW=1/((2*np.pi*dt)**(1/2))*( exp(-(t+dt)**2    /(2*dt))   -   exp(-(t)**2     /(2*dt))  )
                    A=(part_i.getVelocity() + (part_i.gamma+part_i.gamma_t-part_i.gamma_old+part_i.gamma_t_old)/(part_i.getPosition()-part_i.getOlderPosition()) ) 
                    B=(2*(part_i.gamma + part_i.gamma_t))**(1/2)
                    
                    part_i.setPosition( part_i.getPosition()+A * dt + B * dW   )

          #Criando vetores de X, Y, Z e comp para plotagem
            if True:
                for id,part_i in enumerate(part_u):
                    x.append(part_i.x)
                    y.append(part_i.y)
                    z.append(part_i.z)
                    p.append(part_i.comp['H2O'])
                #Plotando e salvando imagens
                plot_3D(x,y,z,p)
                plot_comp(z,p)
                plot_PDF(p)

          #Reação Química
            for id, part_i in enumerate(part_u):
                for element in part_i.gas.species_names:
                    R_p=( 1.0 - part_i.comp[element] ) * exp( - (beta * ( 1.0 - part_i.comp[element] ) ) / ( 1.0 - alpha * ( 1.0 - part_i.comp[element] ) ) )
                    part_i.R_r=PRE_EXP*R_p

          #Calculando a comp média
            npart=len(part_u)
            for id, part_i in enumerate(part_u):
              for element in elementos:
                c_avg[element]+=part_i.comp[element]
                
            for element in elementos:
              c_avg[element] = c_avg[element]/npart

            
            for id,part_i in enumerate(part_u):
              for element in elementos:
                #gama[element]=part_i.gas.mix_diff_coeffs[part_i.gas.species_index(element)]*part_i.gas.density
                part_i.updateGamma(part_i.gas.viscosity)
                part_i.omega[element] = C_omega*(part_i.gamma+part_i.gamma_t)/(delta**2)
                
            for id, part_i in enumerate(part_u):
              for element in range(0,part_i.gas.n_species):
                 name=part_i.gas.species_name(element)
                 part_i.comp[name] += ( (part_i.omega[name] * (part_i.comp[name]-c_avg[name])) + part_i.R_r ) * dt
                 if part_i.comp[name]>1:
                   part_i.comp[name]=1
                 part_i.updateTemp()


            for i_wall in range (0,6):
                npart=int(Wall[i_wall]["Nstring"])
                if npart>0:
                    for dist in np.linspace(0,1,num=npart):
                        u=float(Wall[i_wall]["Ustring"])
                        v=float(Wall[i_wall]["Vstring"])
                        w=float(Wall[i_wall]["Wstring"])
                        T=float(Wall[i_wall]["Tstring"])
                        rand=random()
                        if i_wall==0:
                            x=0
                            y=dist
                            z=rand
                        elif i_wall==1:
                            x=1
                            y=dist
                            z=rand
                        elif i_wall==2:
                            x=dist
                            y=0
                            z=dist
                        elif i_wall==3:
                            x=dist
                            y=1
                            z=rand
                        elif i_wall==4:
                            x=dist
                            y=rand
                            z=0
                        elif i_wall==5:
                            x=dist
                            y=rand
                            z=1
                        comp={}
                        for id, element in enumerate(elementos):
                            comp[element]=float(Wall[i_wall]['stringComposition'][id])

                        part_u.append(part([x,y,z],[u,v,w],comp,T))

         

        ###############################################################################
        ##                          GERAÇÃO DOS GIFS                                 ##
        ###############################################################################
            
        images=[]
        with imageio.get_writer('OUTPUT/3D.gif', mode='I') as writer:
           for filename in filenames_3D:
             image = imageio.imread(filename)
             writer.append_data(image)
             remove(filename)

        images=[]
        with imageio.get_writer('OUTPUT/compositon.gif', mode='I') as writer:
            for filename in filenames_comp:
                image = imageio.imread(filename)
                writer.append_data(image)
                remove(filename)

        images=[]
        with imageio.get_writer('OUTPUT/PDF.gif', mode='I') as writer:
            for filename in filenames_PDF:
                image = imageio.imread(filename)
                writer.append_data(image)
                remove(filename)

        images=[]
        with imageio.get_writer('OUTPUT/CDF.gif', mode='I') as writer:
           for filename in filenames_CDF:
                image = imageio.imread(filename)
                writer.append_data(image)
                remove(filename)


###############################################################################
##                     DEFININDO CONSTANTES E PARÂMETROS                     ##
###############################################################################

global div,n_div,d,k,E_a,T_a,E_a,alpha,beta,gamma,PRE_EXP,delta,C_omega
      
div = 100                                   #divisão da variável z associada ao PDF
n_div = 1/div
d = n_div
k = 0                                       #contador


E_a=83600/9.28 #9000 #8.36 #10.45 #8.36
T_a=E_a/8.315 #10054.0
alpha = (2000.-560.)/2000. #0.7273 #6.
beta =(alpha*T_a)/2000. #2.0 #6.287 #17.95 #13. #10.0d0 #17.95
gamma=0.5*beta**2*(1.0+0.5*beta*(3.0*alpha-1.344)) 
PRE_EXP=(gamma*1.2*1.2)/(0.0000751*exp(-beta/alpha))


delta = 0.1                                 #Tamanho do filtro
C_omega=-2                                   #Constante arbitrária    

###############################################################################
##                       ÍNICIO DA INTERFACE GRÁFICA                         ##
###############################################################################


root = Tk(className=" CHARMANDER : beta version")   
root.iconbitmap('icon.ico')


App(root)
root.mainloop()
root.destroy()